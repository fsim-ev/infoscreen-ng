import { State as TimeState }
	from "shared.slint";

global Language  {
	in property <string> now: "jetzt";
	in property <string> minute-abbr: "min";
	in property <string> hour-abbr: "h";
}

struct Style  {
	font-family: string,
	text-color: brush,
	text-location: brush,

	event-active: brush,
	event-finished: brush,
	event-start: brush,
	event-end: brush,

	task-start: brush,
	task-due: brush,
	task-done: brush,

	block-background: brush,
	border-color: brush,
}

export global State  {
	in property <int> warmup-date: 7 * 86400;
	in property <int> warmup-time: 86400;

	in property <bool> style-dark: true;

	in-out property <Style> style: style-dark ? {
		font-family: "Noto Sans",
		text-color: #fff,
		text-location: #2B2,

		event-start: #6ad,
		event-end: #D2A71F,
		event-active: #D2A71F,
		event-finished: #999,
		
		task-start: #6ad,
		task-due: #f66,
		task-done: #2B2,

		block-background: #32383e,
		border-color: #222,
	} : 
	{
		font-family: "Noto Sans",
		text-color: #111,
		text-location: #2B2,
		
		event-start: #37a,
		event-active: #D2A71F,
		event-end: #A28710,
		event-finished: #999,
		
		task-start: #6ad,
		task-due: #f66,
		task-done: #2B2,

		block-background: #cdc8c1,
		border-color: #888,
	};

	pure callback fmt-time-event(int) -> string;
	pure callback fmt-date-event(int) -> string;

	// Dev helpers
	fmt-time-event(time) => { return "13:37"; }
	fmt-date-event(date) => { return "24.07"; }
}


// UI components
//#################
component TimeBlock inherits VerticalLayout {
	in property <string> main;
	in property <string> second;
	in property <brush> main-color: State.style.event-start;
	in property <brush> second-color: State.style.event-start;

	in property <float> font-scale: 100%;

	property <bool> single: second == "";

	//width: 3.1rem;
	spacing: -0.35rem;
	padding-left: 0.2rem;
	padding-right: self.padding-left;

	Text {
		text: main;
		font-size: (root.single ? 1rem : 0.7rem) * root.font-scale;
		color: root.main-color;
		letter-spacing: root.single ? 0rem : (self.font-size / - 20);

		vertical-alignment: center;
	}
	if !single : Text {
		text: second; 
		font-size: 0.5rem * root.font-scale;

		color: root.second-color;
		horizontal-alignment: right;
		letter-spacing: self.font-size / -20;
	}
}

component TimePanel inherits HorizontalLayout {
	spacing: 5px;
	height: 1.6rem;

	@children
}

component TimeRangeBlock inherits Rectangle {
	in property <float> progress: 0.5;
	in property <color> progress-color: State.style.event-end.mix(State.style.event-start, progress);

	height: 1.6rem;
	background: State.style.block-background.darker(50%);
	border-radius: 0.2rem;
	border-width: (0.0 < progress && progress <= 1.0) ? 0.15rem : 0px;
	border-color: @linear-gradient(95deg, 
		progress-color 0, 
		progress-color progress, 
		self.background progress, 
		self.background 100%);
	clip: true;

	TimePanel {
		@children	
	}
}

component TimeJoin inherits Text {
	width: 1.1rem;
	//font-weight: 200;
	color: State.style.text-color;
	vertical-alignment: center;
	horizontal-alignment: center;
}


// API: Event
//############
export struct Event  {
	summary: string,
	location: string,
	organizer: string,
	color: color,
	categories: string,

	time-start: int,
	time-end: int,
}

component EventEntryPanel inherits Rectangle {
	in property <Event> data;

	in property <float> font-scale: 120%;

	pure function time-color(deadline: int, warmup-time: int) -> color {
	 	State.style.event-end.mix(
	 		State.style.event-start, 
	 		TimeState.time-progress(TimeState.time, deadline - warmup-time, deadline)
	 	)
	}

	property <bool> has-range: true;
	property <int> day-range: TimeState.dur-in-days(data.time-end - data.time-start);
	property <bool> multi-day: TimeState.dur-in-days(data.time-end - data.time-start) > 1;
	property <bool> whole-days: multi-day && TimeState.is-midnight(data.time-start) && TimeState.is-midnight(data.time-end);

	property <float> progress: TimeState.time-progress(TimeState.time, data.time-start, data.time-end);
	property <bool> is-running: progress > 0.0 && progress < 1.0;
	property <bool> is-finished: data.time-end < TimeState.time;

	property <color> date-start-color: time-color(data.time-start, State.warmup-date);
	property <color> date-end-color: time-color(data.time-end, State.warmup-date);
	property <color> time-start-color: time-color(data.time-start, State.warmup-time);
	property <color> time-end-color: time-color(data.time-end, min(data.time-end - data.time-start, 3600 * 6));

	in property <color> text-color: State.style.text-color;

	background: State.style.block-background;
	border-color: State.style.border-color;
	border-width: 2px;
	border-radius: 5px;
	clip: true;

	// Base
	HorizontalLayout {
		alignment: space-between;

		padding: 0.1rem;
		spacing: 0.25rem;

		// Left side
		HorizontalLayout {
			alignment: space-around;
			spacing: 0.3rem;

			/* Time spec. cases:
				1. Start date and time are given:           <date(time-start)> @ <time(time-start)>
				2. Date is given with a time range < 24 h:  <date(time-start)> @ <time(time-start) ↪ time(time-end)>
				3. Only dates are given:                   [<date(time-start)> -> <date(time-end)>]
				4. Dates and times are given:              [<date(time-start) ↪ time(time-start)> -> <date(time-end) ↪ time(time-end)>]
			*/
			Rectangle {
				width: 6.5rem;
				/*
				// case 1: <date(time-start)> @ <time(time-start)>
				if !multi-day && !has-range : TimePanel {
					TimeBlock {
						main: State.fmt-date-event(data.time-start);
						main-color: date-start-color;
					}
					TimeJoin { text: "@"; color: time-start-color; }
					TimeBlock {
						main: State.fmt-time-event(data.time-start);
						main-color: time-start-color;
					}
				}

				// case 2: <date(time-start)> @ <time(time-start) ↪ time(time-end)>
				if !multi-day && has-range : TimePanel {
					TimeBlock {
						main: State.fmt-date-event(data.time-start);
						main-color: date-start-color;
					}
					TimeJoin { text: "@"; color: time-start-color; }
					TimeRangeBlock {
						progress: root.progress;
						TimeBlock {
							in property <string> time-end-str: State.fmt-time-event(data.time-end);
							in property <bool> open-end: time-end-str == "23:55";

							main: tate.fmt-time-event(data.time-start);
							main-color: time-start-color;
							second: "→" + (open-end ? "..." : State.fmt-time-event(data.time-end));
							second-color: time-end-color;
						}
					}
				}
				*/

				// case 2: <date(time-start)> @ <time(time-start) ↪ time(time-end)>
				if !multi-day : TimePanel {
					TimeBlock {
						main: State.fmt-date-event(data.time-start);
						main-color: date-start-color;
					}
					TimeJoin { text: "@ "; color: time-start-color; }
					TimeRangeBlock {
						progress: root.progress;
						TimeBlock {
							main: State.fmt-time-event(data.time-start);
							main-color: time-start-color;
							second: "→ " + State.fmt-time-event(data.time-end);
							second-color: time-end-color;
						}
					}
				}

				// case 3: [<date(time-start)> -> <date(time-end)>]
				if multi-day && whole-days : TimeRangeBlock {
					progress: root.progress;

					TimeBlock {
						main: State.fmt-date-event(data.time-start);
						main-color: date-start-color;
					}
					TimeJoin { text: "→"; color: time-start-color;}
					TimeBlock {
						main: State.fmt-date-event(data.time-end - 86400);
						main-color: date-end-color;
					}
				}

				// case 4: [<date(time-start) ↪ time(time-start)> -> <date(time-end) ↪ time(time-end)>]
				if multi-day && !whole-days : TimeRangeBlock {
					progress: root.progress;
					TimeBlock {
						main: State.fmt-date-event(data.time-start);
						main-color: date-start-color;
						second: "@ " + State.fmt-time-event(data.time-start);
						second-color: time-start-color;
					}
					TimeJoin { text: "→"; color: time-start-color;}
					TimeBlock {
						main: State.fmt-date-event(data.time-end);
						main-color: date-end-color;
						second: "@ " + State.fmt-time-event(data.time-end);
						second-color: time-end-color;
					}
				}
			}
			
			// Summary
			HorizontalLayout {
				alignment: start;
				//width: 40%;
				horizontal-stretch: 2;

				padding-top: 0.1rem;
				padding-bottom: self.padding-top;				

				Text { 
					font-size: 1rem * root.font-scale;
					text: data.summary;
					color: root.is-running ? State.style.event-active 
						: root.is-finished ? State.style.event-finished
						: root.text-color;
					horizontal-alignment: left;
					wrap: word-wrap;
					overflow: elide;
				}
			}
		}

		// Right side
		VerticalLayout {
			padding-right: 0.2rem;
			
			// Location
			Text { 
				text: data.location; 
				font-size: 0.6rem * root.font-scale;
				color: State.style.text-location;

				horizontal-stretch: 0.5;
				horizontal-alignment: right;
				vertical-alignment: top;
			}

			// Categories
			Text { 
				text: data.categories; 
				font-size: 0.4rem * root.font-scale;
				color: State.style.text-color.darker(50%);

				horizontal-stretch: 0.5;
				horizontal-alignment: right;
				vertical-alignment: top;
			}			
		}
	}
}

export component EventPanel inherits Rectangle {
	in property <[Event]> list;
		
	in property <string> direction;
	in property <color> direction-color;
	
	Flickable {
		VerticalLayout {
			alignment: start;
			padding-left: 0.15rem;
			padding-right: self.padding-left;
			spacing: 0.2rem;

			for entry in root.list : EventEntryPanel {
				data: entry;
			}
		}
	}
}


// API: Task
//###########
export struct Task  {
	summary: string,
	organizer: string,
	color: color,

	time-start: int,
	time-due: int,
	priority: int,

	progress: int,
	complete: bool,
}

component TaskEntryPanel inherits Rectangle {
	in property <Task> data;

	pure function time-color(deadline: int, warmup-time: int) -> color {
	 	State.style.event-end.mix(State.style.event-start, TimeState.time-progress(TimeState.time, deadline - warmup-time, deadline))
	}

	property <float> urgency: TimeState.time-progress(TimeState.time, data.time-start, data.time-due);

	property <bool> has-range: data.time-due > 0;
	property <bool> multi-day: has-range && TimeState.dur-in-days(data.time-due - data.time-start) > 0;
	property <bool> whole-days: multi-day && TimeState.is-midnight(data.time-start) && TimeState.is-midnight(data.time-due);

	property <float> progress: data.progress / 100;
	property <bool> is-running: has-range && progress > 0.0 && progress < 1.0;

	property <color> date-start-color: time-color(data.time-start, State.warmup-date);
	property <color> date-due-color: time-color(data.time-due, State.warmup-date);
	property <color> time-start-color: time-color(data.time-start, State.warmup-time);
	property <color> time-due-color: time-color(data.time-due, min(data.time-due - data.time-start, 3600 * 6));

	in property <color> text-color: State.style.text-color;
	in property <color> urgency-color: State.style.task-due.mix(State.style.task-start, progress);
	in property <color> progress-color: State.style.task-done.mix(State.style.task-start, progress);

	background: State.style.block-background.mix(data.color, 40%);
	border-width: 0.1rem;
	border-color: @linear-gradient(95deg, 
		progress-color 0, 
		progress-color progress, 
		self.background progress, 
		self.background 100%);

	border-radius: 5px;
	clip: true;

	// Base
	HorizontalLayout {
		alignment: space-between;

		padding: 0.1rem;
		spacing: 0.4rem;

		HorizontalLayout {
			alignment: start;
			spacing: 0.1rem;

			Rectangle {
				background: State.style.block-background.darker(50%);
				width: 1.5rem;
				Text {
					text: data.complete ? "✔️" : "";
					color: #0c0;
					horizontal-alignment: center;
				}
			}

			// Summary
			HorizontalLayout {
				in property <bool> has-workgroup: data.organizer != "";

				alignment: start;
				spacing: 0.3rem;
				horizontal-stretch: 2;

				padding-top: 0.1rem;
				padding-bottom: self.padding-top;
				padding-left: 0.2rem;

				Text {
					text: data.summary;
					//width: 10%;
					
					font-size: 1rem;
					color: root.text-color;
					horizontal-alignment: left;
					wrap: word-wrap;
					overflow: elide;
				}
			}
		}

//			if data.organizer != "" : Rectangle {
//				background: data.color;
//				border-radius: 8px;
//				HorizontalLayout {
//					padding-left: 0.25rem;
//					padding-right: self.padding-left;
//					Text {
//						text: data.organizer;
//						color: root.text-color;
//						vertical-alignment: center;
//					}
//				}
//			}
		VerticalLayout {
			alignment: start;
//			// Organizer
//			HorizontalLayout {
//				padding-right: 10px;
//				Text { 
//					text: data.organizer; 
//					font-size: 0.6rem;
//					color: data.color;
//					horizontal-stretch: 0.5;
//					horizontal-alignment: right;
//					vertical-alignment: top;
//				}
//			}
//			if data.organizer != "" : Rectangle {
//				background: data.color;
//				border-radius: 8px;
//				HorizontalLayout {
//					padding-left: 0.25rem;
//					padding-right: self.padding-left;
//					alignment: space-around;
//					Text {
//						font-size: 0.6rem;
//						text: data.organizer;
//						color: root.text-color;
//						horizontal-alignment: right;
//						vertical-alignment: top;
//					}
//				}
//			}	
			// Dates
			if data.time-due != 0 : HorizontalLayout {
				padding-left: 0.25rem;
				TimeRangeBlock {
					progress: root.urgency;
					progress-color: root.urgency-color;

					if data.time-start != 0 : TimeBlock {
						main: "von " + State.fmt-date-event(data.time-start);
						main-color: date-start-color;
						second: "@ " + State.fmt-time-event(data.time-start);
						second-color: time-start-color;
					}					
					if data.time-due != 0 : TimeBlock {
						main: "bis " + State.fmt-date-event(data.time-due);
						main-color: date-due-color;
						second: "@ " + State.fmt-time-event(data.time-due);
						second-color: time-due-color;
					}
				}
			}						
//				Text { 
//					text: data.categories; 
//					font-size: 0.4rem;
//					color: State.style.text-color.darker(50%);
//				
//					horizontal-stretch: 0.5;
//					horizontal-alignment: right;
//					vertical-alignment: top;
//				}			
		}
	}
}

export component TaskPanel inherits Rectangle {
	in property <[Task]> list;

	in property <string> direction;
	in property <color> direction-color;
	
	Flickable {
		VerticalLayout {
			alignment: start;
			spacing: 0.2rem;
			padding-left: self.spacing;
			padding-right: self.padding-left;

			for entry in root.list : TaskEntryPanel {
				data: entry;
			}
		}
	}
}
